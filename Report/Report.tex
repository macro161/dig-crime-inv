\documentclass{VUMIFPSmagistrinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{caption}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subfig}
\usepackage{wrapfig}

\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\department{Informatikos institutas}
\papertype{Digital Crime Investigation project}
\title{User Activeness Patterns, tracking Linux OS event patterns}

\author{Matas Savickis and Markas Mikalauskas}

\supervisor{Agnė Brilingaitė, Doc., Dr.}
\date{Vilnius – \the\year}

\bibliography{bibliografija}

\begin{document}
\pagenumbering{arabic}

\maketitle

\tableofcontents



\sectionnonum{Introduction}


\sectionnonum{Existing research solutions}
\section{Viewing system logs}
Viewing system logs is a fundamental step in understanding user and system activities. System logs, such as authentication logs and system messages, offer insights into user logins, logouts, and critical system events. These logs are invaluable for diagnosing issues and monitoring system health. There are simple ways to do that using bash:

\begin{lstlisting}[language=bash]
    # To view authentication logs using the terminal
    cat /var/log/auth.log 

    # To view system messages
    cat /var/log/syslog
\end{lstlisting}

\noindent One of the ways to view system logs using a Python script would be and our use case:
\begin{lstlisting}[language=Python]
import subprocess

log_file = "/var/log/auth.log"
try:
    log_content = subprocess.check_output(['cat', log_file], 
                    universal_newlines=True)
    
    print(log_content)
except FileNotFoundError:
    print(f"Log file {log_file} not found.")
\end{lstlisting}

\subsection{Using journalctl}
\textbf{journalctl} is a command-line utility for accessing the \textbf{systemd} journal logs in Linux. It provides a structured and comprehensive view of system activities, making it a powerful tool for tracking user behavior and system events. Continuous monitoring with the -f flag allows real-time access to logs. It is possible to use this bash command in Python as follows:

\begin{lstlisting}[language=Python]
import subprocess

process = subprocess.Popen(['journalctl', '-f'], 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

while True:
    output = process.stdout.readline().decode()
    if output:
        print(output, end='')
\end{lstlisting}

\section{Audit Framework auditd}
The Linux audit framework, \textbf{auditd}, provides low-level monitoring capabilities. It enables the tracking of system calls, file access, and other critical events. \textbf{auditd} is indispensable for security and compliance monitoring, ensuring a detailed record of user actions.
\begin{lstlisting}[language=Python]
import subprocess

try:
    audit_rules = subprocess.check_output(['auditctl', '-l'], 
        universal_newlines=True)
    print(audit_rules)
except FileNotFoundError:
    print("Auditd is not installed or not running.")
\end{lstlisting}

\section{File System Event Monitoring}
Using tools like \textbf{inotifywait}, Linux offers the ability to monitor file system events in real time. This includes tracking file creations, modifications, deletions, and directory changes. This is crucial for data management, ensuring data integrity, and detecting unauthorized file access.
\begin{lstlisting}[language=Python]
import subprocess

folder_to_watch = '/path/to/watched/folder'

process = subprocess.Popen(['inotifywait', '-m', '-r', 
            folder_to_watch], stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE)

while True:
    output = process.stdout.readline().decode()
    if output:
        print(output, end='')
\end{lstlisting}

\section{Viewing Kernel Messages}
The kernel is at the heart of the Linux operating system, and its messages provide insights into system operations and health. Viewing kernel messages with the dmesg command helps diagnose hardware and driver issues, offering essential information for system administrators.
\begin{lstlisting}[language=Python]
import subprocess

process = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE)

while True:
    output = process.stdout.readline().decode()
    if output:
        print(output, end='')
\end{lstlisting}

\section{Capturing Keyboard and Mouse Events}
Capturing keyboard and mouse events is vital for understanding user interactions. Tools like \textbf{pynput} in Python allow you to record keystrokes and mouse clicks. While this can be useful for monitoring productivity, it should be approached with caution to respect user privacy.

\begin{lstlisting}[language=Python]
from pynput.keyboard import Key, Listener

def on_key_press(key):
    print(f'Key pressed: {key}')

def on_key_release(key):
    if key == Key.esc:
        # Stop listener on pressing ESC key
        return False

with Listener(on_press=on_key_press, on_release=on_key_release) as 
        listener:
    listener.join()
\end{lstlisting}

\section{Idle Time Monitoring}
Monitoring user idle time involves determining periods of inactivity, which can be helpful for various applications, including power management and security. Utilizing tools like \textbf{xprintidle}, it's possible to track idle time based on keyboard and mouse interactions.

\begin{lstlisting}[language=Python]
import subprocess

try:
    idle_time_ms = int(subprocess.check_output(['xprintidle'])
                        .decode())
    idle_time_sec = idle_time_ms / 1000
    print(f'User is idle for {idle_time_sec} seconds.')
except FileNotFoundError:
    print("xprintidle is not installed.")
\end{lstlisting}

\section{Process Monitoring}
Process monitoring, often performed with tools like \textbf{strace}, is essential for tracking the system calls made by running applications. This is instrumental in diagnosing issues and understanding how processes interact with the operating system.


\begin{lstlisting}[language=Python]
import subprocess

pid_to_trace = '1234'  # Replace with the PID of the process 
                            you want to trace

process = subprocess.Popen(['strace', '-p', pid_to_trace], 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

while True:
    output = process.stdout.readline().decode()
    if output:
        print(output, end='')
\end{lstlisting}

\section{Active Window Detection}
Detecting the active window or application in a graphical desktop environment can be achieved with tools like \textbf{ewmh} in Python. It helps in understanding user focus and application usage patterns, which can be valuable for optimizing workflows and identifying resource-intensive tasks.

\begin{lstlisting}[language=Python]
from ewmh import EWMH

ewmh = EWMH()

# Get the root window
root = ewmh.root

# Get the active window
active_window = ewmh.getActiveWindow()

print(f'Active Window Title: {active_window.get_wm_name()}')
\end{lstlisting}

\section{Web Proxy Logs (Squid)}
Squid, a popular web proxy server, generates access logs that record web traffic. Analyzing these logs is critical for tracking user internet activity, ensuring security, and monitoring compliance with internet usage policies. Squid's logs offer insights into web access patterns and can help with content filtering and caching strategies.

\begin{lstlisting}[language=Python]
import subprocess

# Install Squid if it's not already installed
try:
    subprocess.check_output(['apt-get', 'install', 'squid'], 
                stderr=subprocess.STDOUT)
except subprocess.CalledProcessError as e:
    if "E: Unable to locate package" in e.output.decode():
        print("Squid package not found. Please install it manually.")
    else:
        print(e.output.decode())

# Start the Squid service
try:
    subprocess.check_output(['systemctl', 'start', 'squid'], 
        stderr=subprocess.STDOUT)
    print("Squid service started.")
except subprocess.CalledProcessError as e:
    print("Error starting Squid service:")
    print(e.output.decode())

# View Squid access logs
access_log_file = "/var/log/squid/access.log"
try:
    access_log_content = subprocess
                            .check_output(['cat', access_log_file], 
                            universal_newlines=True)
    print(access_log_content)
except FileNotFoundError:
    print(f"Squid access log file {access_log_file} not found.")
\end{lstlisting}

\sectionnonum{Technological challenges}

	
\sectionnonum{Hypotheses}

	
\sectionnonum{Design of the tool}


\sectionnonum{Algorithm}


\sectionnonum{Visual report/diagnostics}


		
\pagebreak
\printbibliography[heading=bibintoc] 

\end{document}
